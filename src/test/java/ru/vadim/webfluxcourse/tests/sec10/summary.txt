Давайте быстро подведем итоги того, что мы сделали в этом разделе.
Вот некоторые из рассмотренных нами методов, которые могут помочь улучшить масштабируемость вашего приложения.
Первый — gzip.
Если у вас перегруженная сеть и размер ответа большой из-за сети, клиент может
потребуется некоторое время, чтобы получить ответ.
Это наблюдаемое время отклика.
Из-за этого его соединение будет заблокировано, и он не сможет отправить последующий запрос, поэтому
это повлияет на общую производительность приложения.
Gzip может сжимать ответ, что может улучшить время отклика и пропускную способность приложения.
Поэтому попробуйте включить gzip, чтобы посмотреть, поможет ли это в вашем случае, и не используйте локальную машину для тестирования, чтобы вы
необходимо провести реальные испытания производительности на уровне производства, чтобы увидеть результаты.
Тогда объединение подключений в пул с настройкой соединения займет время.
Мы не можем настраивать новое соединение как часть каждого отдельного запроса, поэтому это определенно повлияет на производительность.
Поэтому включите Keepalive, чтобы попытаться повторно использовать соединение для последующих запросов.
Веб-клиент делает это автоматически, но если вам нужно настроить размер пула и т.п., то это время
вам придется включить сжатие Keepalive самостоятельно как часть конфигурации.
Помните, что 500 подключений — это на самом деле много для большинства случаев использования.
Поэтому я хочу, чтобы вы запомнили эту формулу.
Количество соединений, деленное на.
Каково среднее время ответа удаленной службы?
Если количество подключений равно 500, среднее время отклика составляет 100 миллисекунд.
Тогда, используя соединение 500, мы сможем обрабатывать 5000 запросов в секунду.
Теперь вам придется спросить себя.
Вы действительно получаете больше?
То есть, в этом случае вам придется обрабатывать более 5000 запросов в секунду?
Если вы так считаете, то да, тогда вам придется скорректировать размер пула соединений.
В противном случае я бы вообще к этому не притрагивался.
Также помните, что ваша операционная система будет иметь лишь ограниченное количество ресурсов.
Он не может продолжать создавать новые связи.
Что бы вы ни попросили.
Например, вы не можете запросить 10 000 подключений или 20 000 подключений.
В конце концов вы увидите своего рода узкое место.
Возможно, у вас недостаточно исходящих портов для настройки подключений.
Так что в данном случае мы мало что можем сделать.
Поэтому, если возможно, используйте HTTP два.
В этом случае HTTP 2 позволяет отправлять и получать несколько запросов и ответов одновременно на
мультиплексирование одного соединения.
Таким образом, используя это, вы сможете преодолеть ограничения HTTP 1.1.
Тогда не блокируйте поток цикла событий.
Старайтесь использовать реактивный драйвер как можно чаще, но если нам придется использовать блокирующий драйвер или библиотеку для
ваше приложение, то в этом случае вам придется использовать оператор подписки с ограниченной эластичностью
Планировщик.
Не все проблемы можно решить, просто добавив пару свойств в наше приложение.
Иногда нам может потребоваться другой инструмент и технология, чтобы сделать наше приложение более масштабируемым и устойчивым.
Теперь я буду бесстыдно рекомендовать некоторые из моих других курсов.
Первой станет Radius — сверхбыстрая система хранения данных, разработанная для приложений, которым требуется
доступ к данным в реальном времени.
Именно это и делает Radius.
Это упрощает такие задачи, как кэширование, управление данными и т. д.
Затем GraphQL.
Это необходимо для эффективной передачи данных между интерфейсом и сервером.
Затем спроектируйте шаблоны, которые сделают ваше приложение более устойчивым и способным обрабатывать распределенные транзакции.
В рамках этого курса мы обсуждаем около десяти различных шаблонов проектирования в наших микросервисах.
архитектура.
Так что если вам интересно, вы, вероятно, можете это проверить.